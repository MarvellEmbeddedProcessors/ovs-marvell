From 06f9b69f2cf5d301198e876310ee54babc06a55d Mon Sep 17 00:00:00 2001
From: nsamsono <nsamsono@marvell.com>
Date: Thu, 26 Oct 2017 16:26:45 +0300
Subject: [PATCH 1/5] net: mrvl: fix initial configurations before start device

In case of calling configuration functions such as set MTU or
set MAC address before start device where ppio object is
created, save config parameters and perform actual configuration
on device start

Change-Id: I08f0b7ad63dd31c5992c7059dcbc266145ed9bed
Signed-off-by: nsamsono <nsamsono@marvell.com>
---
 drivers/net/mrvl/mrvl_ethdev.c | 317 ++++++++++++++++++++++++++---------------
 drivers/net/mrvl/mrvl_ethdev.h |  18 +++
 2 files changed, 219 insertions(+), 116 deletions(-)

diff --git a/drivers/net/mrvl/mrvl_ethdev.c b/drivers/net/mrvl/mrvl_ethdev.c
index 3282284..e184b4c 100644
--- a/drivers/net/mrvl/mrvl_ethdev.c
+++ b/drivers/net/mrvl/mrvl_ethdev.c
@@ -31,7 +31,6 @@
  *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include <rte_ethdev.h>
 #include <rte_kvargs.h>
 #include <rte_log.h>
 #include <rte_malloc.h>
@@ -72,8 +71,7 @@
 /* prefetch shift */
 #define MRVL_MUSDK_PREFETCH_SHIFT 2
 
-/* TCAM has 25 entries reserved for uc/mc filter entries */
-#define MRVL_MAC_ADDRS_MAX 25
+/* Maximum match string length */
 #define MRVL_MATCH_LEN 16
 #define MRVL_PKT_EFFEC_OFFS (MRVL_PKT_OFFS + MV_MH_SIZE)
 /* Maximum allowable packet size */
@@ -284,6 +282,12 @@ struct mrvl_txq {
 	if ((mtu < ETHER_MIN_MTU) || (mru > MRVL_PKT_SIZE_MAX))
 		return -EINVAL;
 
+	if (!priv->ppio) {
+		priv->init_cfg.is_set_mtu = 1;
+		priv->init_cfg.mtu = mtu;
+		return 0;
+	}
+
 	ret = pp2_ppio_set_mru(priv->ppio, mru);
 	if (ret)
 		return ret;
@@ -297,6 +301,11 @@ struct mrvl_txq {
 	struct mrvl_priv *priv = dev->data->dev_private;
 	int ret;
 
+	if (!priv->ppio) {
+		priv->init_cfg.is_link_down = 0;
+		return 0;
+	}
+
 	ret = pp2_ppio_enable(priv->ppio);
 	if (ret)
 		return ret;
@@ -323,6 +332,10 @@ struct mrvl_txq {
 	struct mrvl_priv *priv = dev->data->dev_private;
 	int ret;
 
+	if (!priv->ppio) {
+		priv->init_cfg.is_link_down = 1;
+		return 0;
+	}
 	ret = pp2_ppio_disable(priv->ppio);
 	if (ret)
 		return ret;
@@ -332,13 +345,158 @@ struct mrvl_txq {
 	return ret;
 }
 
+static void
+mrvl_promiscuous_enable(struct rte_eth_dev *dev)
+{
+	struct mrvl_priv *priv = dev->data->dev_private;
+	int ret;
+
+	if (!priv->ppio) {
+		priv->init_cfg.is_promisc = 1;
+		return;
+	}
+
+	ret = pp2_ppio_set_promisc(priv->ppio, 1);
+	if (ret)
+		RTE_LOG(ERR, PMD, "Failed to enable promiscuous mode\n");
+}
+
+static void
+mrvl_allmulticast_enable(struct rte_eth_dev *dev)
+{
+	struct mrvl_priv *priv = dev->data->dev_private;
+	int ret;
+
+	if (!priv->ppio) {
+		priv->init_cfg.is_mc_promisc = 1;
+		return;
+	}
+
+	ret = pp2_ppio_set_mc_promisc(priv->ppio, 1);
+	if (ret)
+		RTE_LOG(ERR, PMD, "Failed enable all-multicast mode\n");
+}
+
+static void
+mrvl_promiscuous_disable(struct rte_eth_dev *dev)
+{
+	struct mrvl_priv *priv = dev->data->dev_private;
+	int ret;
+
+	if (!priv->ppio) {
+		priv->init_cfg.is_promisc = 0;
+		return;
+	}
+
+	ret = pp2_ppio_set_promisc(priv->ppio, 0);
+	if (ret)
+		RTE_LOG(ERR, PMD, "Failed to disable promiscuous mode\n");
+}
+
+static void
+mrvl_allmulticast_disable(struct rte_eth_dev *dev)
+{
+	struct mrvl_priv *priv = dev->data->dev_private;
+	int ret;
+
+	if (!priv->ppio) {
+		priv->init_cfg.is_mc_promisc = 0;
+		return;
+	}
+
+	ret = pp2_ppio_set_mc_promisc(priv->ppio, 0);
+	if (ret)
+		RTE_LOG(ERR, PMD, "Failed to disable all-multicast mode\n");
+}
+
+static void
+mrvl_mac_addr_remove(struct rte_eth_dev *dev, uint32_t index)
+{
+	struct mrvl_priv *priv = dev->data->dev_private;
+	char buf[ETHER_ADDR_FMT_SIZE];
+	int ret;
+
+	if (!priv->ppio)
+		return;
+
+	ret = pp2_ppio_remove_mac_addr(priv->ppio,
+				       dev->data->mac_addrs[index].addr_bytes);
+	if (ret) {
+		ether_format_addr(buf, sizeof(buf),
+				  &dev->data->mac_addrs[index]);
+		RTE_LOG(ERR, PMD, "Failed to remove mac %s\n", buf);
+	}
+}
+
+static int
+mrvl_mac_addr_add(struct rte_eth_dev *dev, struct ether_addr *mac_addr,
+		  uint32_t index, uint32_t vmdq __rte_unused)
+{
+	struct mrvl_priv *priv = dev->data->dev_private;
+	char buf[ETHER_ADDR_FMT_SIZE];
+	int ret;
+
+	if (index == 0)
+		/* For setting index 0, mrvl_mac_addr_set() should be used.*/
+		return -1;
+
+	if (!priv->ppio) {
+		uint32_t idx = priv->init_cfg.mac_addr_add_num;
+
+		priv->init_cfg.mac_addr_to_add_idx[idx] = index;
+		memcpy(&priv->init_cfg.mac_addr_to_add[idx],
+			mac_addr, sizeof(*mac_addr));
+		priv->init_cfg.mac_addr_add_num++;
+		return 0;
+	}
+
+	/*
+	 * Maximum number of uc addresses can be tuned via kernel module mvpp2x
+	 * parameter uc_filter_max. Maximum number of mc addresses is then
+	 * MRVL_MAC_ADDRS_MAX - uc_filter_max. Currently it defaults to 4 and
+	 * 21 respectively.
+	 *
+	 * If more than uc_filter_max uc addresses were added to filter list
+	 * then NIC will switch to promiscuous mode automatically.
+	 *
+	 * If more than MRVL_MAC_ADDRS_MAX - uc_filter_max number mc addresses
+	 * were added to filter list then NIC will switch to all-multicast mode
+	 * automatically.
+	 */
+	ret = pp2_ppio_add_mac_addr(priv->ppio, mac_addr->addr_bytes);
+	if (ret) {
+		ether_format_addr(buf, sizeof(buf), mac_addr);
+		RTE_LOG(ERR, PMD, "Failed to add mac %s\n", buf);
+		return -1;
+	}
+
+	return 0;
+}
+
+static void
+mrvl_mac_addr_set(struct rte_eth_dev *dev, struct ether_addr *mac_addr)
+{
+	struct mrvl_priv *priv = dev->data->dev_private;
+
+	RTE_LOG(INFO, PMD, "mrvl_mac_addr_set %s: ppio: %p\n",
+		dev->data->name, priv->ppio);
+
+	if (!priv->ppio) {
+		priv->init_cfg.is_mac_addr_to_set = 1;
+		memcpy(&priv->init_cfg.mac_addr_to_set,
+			mac_addr, sizeof(*mac_addr));
+		return;
+	}
+
+	pp2_ppio_set_mac_addr(priv->ppio, mac_addr->addr_bytes);
+}
 
 static int
 mrvl_dev_start(struct rte_eth_dev *dev)
 {
 	struct mrvl_priv *priv = dev->data->dev_private;
 	char match[MRVL_MATCH_LEN];
-	int ret;
+	int ret = 0, i;
 
 	snprintf(match, sizeof(match), "ppio-%d:%d", priv->pp_id, priv->ppio_id);
 	priv->ppio_params.match = match;
@@ -389,6 +547,29 @@ struct mrvl_txq {
 		}
 		priv->vlan_flushed = 1;
 	}
+	/*
+	 * In case that some initial configurations were done before ppio
+	 * object was initialized perform them here.
+	 */
+
+	if (priv->init_cfg.is_set_mtu) {
+		ret = mrvl_mtu_set(dev, priv->init_cfg.mtu);
+		if (ret)
+			goto out;
+	}
+
+	if (priv->init_cfg.is_promisc)
+		mrvl_promiscuous_enable(dev);
+	else
+		if (priv->init_cfg.is_mc_promisc)
+			mrvl_allmulticast_enable(dev);
+
+	if (priv->init_cfg.is_mac_addr_to_set)
+		mrvl_mac_addr_set(dev, &priv->init_cfg.mac_addr_to_set);
+
+	for (i = 0; i < priv->init_cfg.mac_addr_add_num; i++)
+		mrvl_mac_addr_add(dev, &priv->init_cfg.mac_addr_to_add[i],
+				  priv->init_cfg.mac_addr_to_add_idx[i], 0);
 
 	/* For default QoS config, don't start classifier. */
 	if (mrvl_qos_cfg != NULL) {
@@ -399,12 +580,15 @@ struct mrvl_txq {
 		}
 	}
 
-	ret = mrvl_dev_set_link_up(dev);
-	if (ret)
-		goto out;
+	if (!priv->init_cfg.is_link_down) {
+		ret = mrvl_dev_set_link_up(dev);
+		if (ret)
+			goto out;
+	}
 
 	return 0;
 out:
+	RTE_LOG(ERR, PMD, "Failed to start device\n");
 	pp2_ppio_deinit(priv->ppio);
 	return ret;
 }
@@ -546,7 +730,7 @@ struct mrvl_txq {
 	case SPEED_1000:
 		dev->data->dev_link.link_speed = ETH_SPEED_NUM_1G;
 		break;
-        case SPEED_10000:
+	case SPEED_10000:
 		dev->data->dev_link.link_speed = ETH_SPEED_NUM_10G;
 		break;
 	default:
@@ -562,114 +746,6 @@ struct mrvl_txq {
 }
 
 static void
-mrvl_promiscuous_enable(struct rte_eth_dev *dev)
-{
-	struct mrvl_priv *priv = dev->data->dev_private;
-	int ret;
-
-	ret = pp2_ppio_set_promisc(priv->ppio, 1);
-	if (ret)
-		RTE_LOG(ERR, PMD, "Failed to enable promiscuous mode\n");
-}
-
-static void
-mrvl_allmulticast_enable(struct rte_eth_dev *dev)
-{
-	struct mrvl_priv *priv = dev->data->dev_private;
-	int ret;
-
-	ret = pp2_ppio_set_mc_promisc(priv->ppio, 1);
-	if (ret)
-		RTE_LOG(ERR, PMD, "Failed enable all-multicast mode\n");
-}
-
-static void
-mrvl_promiscuous_disable(struct rte_eth_dev *dev)
-{
-	struct mrvl_priv *priv = dev->data->dev_private;
-	int ret;
-
-	ret = pp2_ppio_set_promisc(priv->ppio, 0);
-	if (ret)
-		RTE_LOG(ERR, PMD, "Failed to disable promiscuous mode\n");
-}
-
-static void
-mrvl_allmulticast_disable(struct rte_eth_dev *dev)
-{
-	struct mrvl_priv *priv = dev->data->dev_private;
-	int ret;
-
-	ret = pp2_ppio_set_mc_promisc(priv->ppio, 0);
-	if (ret)
-		RTE_LOG(ERR, PMD, "Failed to disable all-multicast mode\n");
-}
-
-static void
-mrvl_mac_addr_remove(struct rte_eth_dev *dev, uint32_t index)
-{
-	struct mrvl_priv *priv = dev->data->dev_private;
-	char buf[ETHER_ADDR_FMT_SIZE];
-	int ret;
-
-	ret = pp2_ppio_remove_mac_addr(priv->ppio, dev->data->mac_addrs[index].addr_bytes);
-	if (ret) {
-		ether_format_addr(buf, sizeof(buf), &dev->data->mac_addrs[index]);
-		RTE_LOG(ERR, PMD, "Failed to remove mac %s\n", buf);
-	}
-}
-
-static int
-mrvl_mac_addr_add(struct rte_eth_dev *dev, struct ether_addr *mac_addr,
-		  uint32_t index, uint32_t vmdq __rte_unused)
-{
-	struct mrvl_priv *priv = dev->data->dev_private;
-	char buf[ETHER_ADDR_FMT_SIZE];
-	int ret;
-
-	if (index == 0)
-		/* For setting index 0, mrvl_mac_addr_set() should be used.*/
-		return -1;
-
-	/*
-	 * Maximum number of uc addresses can be tuned via kernel module mvpp2x
-	 * parameter uc_filter_max. Maximum number of mc addresses is then
-	 * MRVL_MAC_ADDRS_MAX - uc_filter_max. Currently it defaults to 4 and
-	 * 21 respectively.
-	 *
-	 * If more than uc_filter_max uc addresses were added to filter list
-	 * then NIC will switch to promiscuous mode automatically.
-	 *
-	 * If more than MRVL_MAC_ADDRS_MAX - uc_filter_max number mc addresses
-	 * were added to filter list then NIC will switch to all-multicast mode
-	 * automatically.
-	 */
-	ret = pp2_ppio_add_mac_addr(priv->ppio, mac_addr->addr_bytes);
-	if (ret) {
-		ether_format_addr(buf, sizeof(buf), mac_addr);
-		RTE_LOG(ERR, PMD, "Failed to add mac %s\n", buf);
-		return -1;
-	}
-
-	return 0;
-}
-
-static void
-mrvl_mac_addr_set(struct rte_eth_dev *dev, struct ether_addr *mac_addr)
-{
-	struct mrvl_priv *priv = dev->data->dev_private;
-
-	pp2_ppio_set_mac_addr(priv->ppio, mac_addr->addr_bytes);
-	/*
-	 * TODO
-	 * Port stops sending packets if pp2_ppio_set_mac_addr()
-	 * was called after pp2_ppio_enable(). As a quick fix issue
-	 * enable port once again.
-	 */
-	pp2_ppio_enable(priv->ppio);
-}
-
-static void
 mrvl_stats_get(struct rte_eth_dev *dev, struct rte_eth_stats *stats)
 {
 	struct mrvl_priv *priv = dev->data->dev_private;
@@ -677,6 +753,9 @@ struct mrvl_txq {
 	uint64_t drop_mac = 0;
 	unsigned i, idx, ret;
 
+	if (!priv->ppio)
+		return;
+
 	for (i = 0; i < dev->data->nb_rx_queues; i++) {
 		struct mrvl_rxq *rxq = dev->data->rx_queues[i];
 		struct pp2_ppio_inq_statistics rx_stats;
@@ -756,6 +835,9 @@ struct mrvl_txq {
 	struct mrvl_priv *priv = dev->data->dev_private;
 	int i;
 
+	if (!priv->ppio)
+		return;
+
 	for (i = 0; i < dev->data->nb_rx_queues; i++) {
 		struct mrvl_rxq *rxq = dev->data->rx_queues[i];
 
@@ -853,6 +935,9 @@ static void mrvl_txq_info_get(struct rte_eth_dev *dev, uint16_t tx_queue_id,
 {
 	struct mrvl_priv *priv = dev->data->dev_private;
 
+	if (!priv->ppio)
+		return 0;
+
 	return on ? pp2_ppio_add_vlan(priv->ppio, vlan_id) :
 		    pp2_ppio_remove_vlan(priv->ppio, vlan_id);
 }
diff --git a/drivers/net/mrvl/mrvl_ethdev.h b/drivers/net/mrvl/mrvl_ethdev.h
index be41409..58ac89a 100644
--- a/drivers/net/mrvl/mrvl_ethdev.h
+++ b/drivers/net/mrvl/mrvl_ethdev.h
@@ -35,6 +35,7 @@
 #define _MRVL_ETHDEV_H_
 
 #include <rte_spinlock.h>
+#include <rte_ethdev.h>
 #include <env/mv_autogen_comp_flags.h>
 #include <drivers/mv_pp2_cls.h>
 #include <drivers/mv_pp2_ppio.h>
@@ -82,6 +83,22 @@
 /** Minimum number of sent buffers to release from shadow queue to BM */
 #define MRVL_PP2_BUF_RELEASE_BURST_SIZE	64
 
+/* TCAM has 25 entries reserved for uc/mc filter entries */
+#define MRVL_MAC_ADDRS_MAX 25
+
+struct mrvl_config {
+	int is_set_mtu;
+	uint16_t mtu;
+	int is_link_down;
+	int is_promisc;
+	int is_mc_promisc;
+	uint32_t mac_addr_to_add_idx[MRVL_MAC_ADDRS_MAX];
+	struct ether_addr mac_addr_to_add[MRVL_MAC_ADDRS_MAX];
+	int mac_addr_add_num;
+	struct ether_addr mac_addr_to_set;
+	int is_mac_addr_to_set;
+};
+
 struct mrvl_priv {
 	/* Hot fields, used in fast path. */
 	struct pp2_bpool *bpool;  /**< BPool pointer */
@@ -104,6 +121,7 @@ struct mrvl_priv {
 	uint8_t rss_hf_tcp;
 	uint8_t uc_mc_flushed;
 	uint8_t vlan_flushed;
+	struct mrvl_config init_cfg;
 
 	struct pp2_ppio_params ppio_params;
 	struct pp2_cls_qos_tbl_params qos_tbl_params;
-- 
1.9.1

